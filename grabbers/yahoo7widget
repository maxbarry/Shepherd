#!/usr/bin/perl -w

# yahoo7_widget au_tv guide grabber - runs from "Shepherd" master grabber
#  * written by ltd
#  * uses yahoo7 widget for ABC/7/9/10/SBS (all they have)
#  * when used in conjunction with Shepherd, shepherd can collect other channels
#    using other grabbers
#  * this does NOT use any config file - all settings are passed in from shepherd

#  changelog:
#    1.50  22sep06	added support for "shepherd" master grabber script
#    1.51  02oct06      --ready option
#    1.52  03oct06      split out yahoo7 grabber into its own grabber
#    1.54  16oct06      put date/cast/credits/year into correct xmltv fields
#    1.70  15dec06	sometimes there are holes in data; augment those from yahoo7web
#    1.78  04feb07	remove augmenting - micrograbbing from other grabbers
#			can now fill those in
#    1.80  22feb07	bugfix: stop throwing away multiple category data
#    1.81  01mar07      more informative error on no connectivity
#    2.00  19jun10	moved to JSON data format

use strict;

my $progname = "yahoo7widget";
my $version = "2.0";

use XMLTV;
use POSIX qw(strftime mktime);
use Getopt::Long;
use Data::Dumper;
use Shepherd::Common;
use JSON;

#
# some initial cruft
#

my $script_start_time = time;
my %stats;
my $channels, my $opt_channels;
my $tv_guide;
my $input_xml;
my $d;
$| = 1;

#
# parse command line
#

my $opt;
$opt->{outputfile} = 	"output.xmltv";	# default
$opt->{days} = 		7;		# default
$opt->{lang} =		"en";
$opt->{region} =	94;

GetOptions(
	'region=i'	=> \$opt->{region},
	'days=i'	=> \$opt->{days},
	'offset=i'	=> \$opt->{offset},
	'channels_file=s' => \$opt->{channels_file},
	'cachefile=s' => \$opt->{obsolete},
	'output=s'	=> \$opt->{outputfile},
	'fast'		=> \$opt->{fast},
	'warper'	=> \$opt->{warper},
	'lang=s'	=> \$opt->{lang},
	'obfuscate'	=> \$opt->{obfuscate},
	'debug+'	=> \$opt->{debug},
	'help'		=> \$opt->{help},
	'verbose'	=> \$opt->{help},
	'version'	=> \$opt->{version},
	'ready'		=> \$opt->{version},
	'desc'		=> \$opt->{desc},
	'v'		=> \$opt->{help});

&help if (defined $opt->{help});

if (defined $opt->{version} || defined $opt->{desc}) {
	printf "%s %s\n",$progname,$version;
	printf "%s is a details-aware grabber that collects very high quality data (full title/subtitle/description/genre and year/cast/credits data) using the Yahoo7 website.",$progname if (defined $opt->{desc});
	exit(0);
}

# set defaults
Shepherd::Common::set_default("debug", ($opt->{debug} * 2)) if (defined $opt->{debug});
Shepherd::Common::set_default("webwarper", 1) if (defined $opt->{warper});
Shepherd::Common::set_default("squid", 1) if (defined $opt->{obfuscate});
Shepherd::Common::set_default("referer", "last");
Shepherd::Common::set_default("retry_delay", 10);
Shepherd::Common::setup_ua('agent' => 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-us)');

die "no channel file specified, see --help for instructions\n", unless (defined $opt->{channels_file});

$opt->{days} = 9 if $opt->{days} > 9;	# no data beyond 9 days

#
# go go go!
#

my $starttime = $script_start_time;

# normalize starttime to 3 hour window to help yahoo's squid cache entries
$starttime -= ($starttime % (3*3600));

# correct $starttime to remove gap between local and Eastern States time
my $local_time_offset = POSIX::strftime("%z",localtime(time));
# yahoo7widget times are always localtime on Eastern States ..
$ENV{TZ}="Australia/Melbourne";
my $melbourne_time_offset = POSIX::strftime("%z",localtime(time));
my $time_offset = ((int(substr($melbourne_time_offset,1,2))-int(substr($local_time_offset,1,2)))*(60*60)) +
                ((int(substr($melbourne_time_offset,3,2))-int(substr($local_time_offset,3,2)))*(60));
$starttime -= $time_offset;

my $endtime = $starttime + ($opt->{days} * 86400);
$starttime += (86400 * $opt->{offset}) if (defined $opt->{offset});

Shepherd::Common::log(sprintf "going to grab %d days%s of data into %s (%s%s) region %s",
	$opt->{days},
	($opt->{offset} ? " (skipping first $opt->{offset} days)" : ""),
	$opt->{outputfile},
	(defined $opt->{fast} ? "with haste" : "slowly"),
	(defined $opt->{warper} ? ", anonymously" : ""),
	$opt->{region});

if (-r $opt->{channels_file}) {
	local (@ARGV, $/) = ($opt->{channels_file});
	no warnings 'all'; eval <>; die "$@" if $@;
} else {
	die "WARNING: channels file $opt->{channels_file} could not be read\n";
}

for (my $currtime = $starttime; $currtime < $endtime; $currtime += (6*3600)) {
	# pace ourselves
	if (($currtime != $starttime) && (!defined $opt->{fast})) {
		my $sleeptimer = int(rand(5)) + 1;  # sleep anywhere from 1 to 5 seconds
		$stats{slept_for} += $sleeptimer;
		sleep $sleeptimer;
	}

	# get data
	my $tries = 5;
	my $url = sprintf "http://au.tv.yahoo.com/tv-guide/data/%d/0/%d/%d/", $opt->{region}, $currtime,($currtime+(6*3600));
	my ($data, $success, $status_msg, $bytes_fetched, $seconds_slept, $failed_attempts, $response) = 
	  Shepherd::Common::get_url(url => $url, retries => ($tries-1));

	$stats{failed_requests} += $failed_attempts;
	$stats{slept_for} += $seconds_slept;
	$stats{bytes_fetched} += $bytes_fetched;

	if ((!$data) || (!$success)) {
		Shepherd::Common::log("Failed to fetch '$url' after $tries attempts.");

		# if its our first page, abort now
		if ($currtime == $starttime) {
			Shepherd::Common::log("Aborting: likely format change or blocked!");
			exit 10;
		}
		next;
	}

	$stats{http_successful_requests}++;
	&parse_json_data($data);
}

&write_data;
Shepherd::Common::print_stats($progname, $version, $script_start_time, %stats);
exit(0);

######################################################################################################
# help

sub help
{
	print<<EOF
$progname $version

$0 [options]
    options are as follows:
	--region=N		set region for where to collect data from (default: $opt->{region})
	--channels_file=file	where to get channel data from (MANDATORY)
	--days=N		fetch 'n' days of data (default: $opt->{days})
	--output=file		send xml output to file (default: "$opt->{outputfile}")

	--fast			don't run slow - get data as quick as you can - not recommended
	--debug			increase debug level
	--warper		fetch data using WebWarper web anonymizer service
	--obfuscate		pretend to be a proxy servicing multiple clients
	--lang=[s]		set language of xmltv output data (default $opt->{lang})

EOF
;

	exit(0);
}

######################################################################################################
# parse it into $tv_guide->{$channel}->{data}->{$event_id}-> structures..

sub parse_json_data
{
	my $data = shift;

	unless (($data) && (length($data) > 1)) {
	    print STDERR "ERROR: no data to parse.\n";
	    return;
	}

	my $decoded_data = decode_json($data);
	foreach my $item (@{($decoded_data->{'tv'}->[0]->{'item'})}) {
		my $channel = $item->{'co_v_short'};
		if ((!defined $channels->{$channel}) && (!defined $opt_channels->{$channel})) {
			if (!defined $d->{ignored_channels}->{$channel}) {
				$d->{ignored_channels}->{$channel} = 1;
				$stats{skipped_channels}++;
				Shepherd::Common::log("ignoring unknown channel '$channel'");
			}
			next;
		}

		my $event_id = $item->{'event_id'};

		# mandatory fields
		my $event_start = $item->{'event_date'}->[0]->{timestamp};
		my $event_end =   $item->{'end_date'}->[0]->{timestamp};

		if ($event_start < 10) {
			$stats{progs_with_invalid_start}++;
			printf "WARNING: programme with event_id '$event_id' had an invalid start time of '$event_start'; skipped\n";
			next;
		}
		if ($event_end < 10) {
			$stats{progs_with_invalid_end}++;
			printf "WARNING: programme with event_id '$event_id' had an invalid end time of '$event_end'; skipped\n";
			next;
		}

		$event_id = $event_start.":".$event_end.":".$event_id; # event_id actually isn't unique - so make it so

		$stats{programmes}++;
		$stats{duplicate_programmes}++ if ($tv_guide->{$channel}->{data}->{$event_id});

		# store it in the correct XMLTV schema!
		$tv_guide->{$channel}->{data}->{$event_id}->{'channel'} = $channels->{$channel} if (defined $channels->{$channel});
		$tv_guide->{$channel}->{data}->{$event_id}->{'channel'} = $opt_channels->{$channel} if (defined $opt_channels->{$channel});

		$tv_guide->{$channel}->{data}->{$event_id}->{'start'} = POSIX::strftime("%Y%m%d%H%M", localtime($event_start));
		$tv_guide->{$channel}->{data}->{$event_id}->{'stop'} = 	POSIX::strftime("%Y%m%d%H%M", localtime($event_end));

		$tv_guide->{$channel}->{data}->{$event_id}->{'title'} = 	[[ $item->{title}->[0]->{0}, $opt->{lang} ]] if (defined $item->{title});
		$tv_guide->{$channel}->{data}->{$event_id}->{'desc'} = 		[[ $item->{description_1}, $opt->{lang} ]] if (defined $item->{description_1});

		my %genre, my $category;
		$genre{movie} = 1 if ((defined $item->{show_type}) && ($item->{show_type} eq "Movie"));
		$genre{live} = 1 if (defined $item->{live});
		$genre{$item->{genre}} = 1 if (defined $item->{genre});
		$category = $item->{'category'}->[0]->{'item'}->[0]->{0} if ((defined $item->{'category'}) && (defined $item->{'category'}->[0]->{'item'}->[0]->{0}));
		$tv_guide->{$channel}->{data}->{$event_id}->{'category'} = 	[ &Shepherd::Common::generate_category($item->{title}->[0]->{0}, $category, %genre) ];

		$tv_guide->{$channel}->{data}->{$event_id}->{'country'} = 	[ map([$_,$opt->{lang}], split(/\//, $item->{country})) ] if (defined $item->{country});
		$tv_guide->{$channel}->{data}->{$event_id}->{'premiere'} = 	[ 'premiere', $opt->{lang} ] if (defined $item->{'premiere'});

		my $rating = "";
		$rating .= $item->{rating} if (defined $item->{'rating'});
		$rating .= " ".lc($item->{warnings}) if (defined $item->{'warnings'});
		$tv_guide->{$channel}->{data}->{$event_id}->{'rating'} =	[[ $rating, 'ABA', undef ]] if $rating ne "";

		$tv_guide->{$channel}->{data}->{$event_id}->{'credits'}{'actor'} = [ split(/, /, $item->{main_cast}) ] if (defined $item->{main_cast});
		$tv_guide->{$channel}->{data}->{$event_id}->{'credits'}{'director'} = [ split(/, /, $item->{director}) ] if (defined $item->{director});
		$tv_guide->{$channel}->{data}->{$event_id}->{'credits'}{'writer'} = [ split(/, /, $item->{writer}) ] if (defined $item->{writer}); # unseen
		$tv_guide->{$channel}->{data}->{$event_id}->{'date'} = 	$item->{year_released} if (defined $item->{year_released});
		$tv_guide->{$channel}->{data}->{$event_id}->{'previously-shown'} = { } if (defined $item->{repeat});
		$tv_guide->{$channel}->{data}->{$event_id}->{'subtitles'} = 	[ { 'type' => 'teletext' } ] if (defined $item->{captions});
		$tv_guide->{$channel}->{data}->{$event_id}->{'last-chance'} = 	[ 'final', $opt->{lang} ] if (defined $item->{final});

		my %video_details;
		if ((defined $item->{colour}) && ($item->{colour} == 1)) {
			$video_details{'colour'} = 1;
			$tv_guide->{$channel}->{data}->{$event_id}->{'video'} = \%video_details;
		}

		$tv_guide->{$channel}->{data}->{$event_id}->{'length'} = ($item->{running_time} * 60) if (defined $item->{running_time});
		$tv_guide->{$channel}->{data}->{$event_id}->{'language'} = [ $item->{language}, $opt->{lang} ] if (defined $item->{language});

		$d->{seen_progs}->{$channel}++;

		# print out any unused fields
		foreach my $field (keys %{($item)}) {
			next if ($field =~ /(event_id|co_v_short|event_date|end_date|title|description_1|show_type|category|country|premiere|rating|warnings|main_cast|director|writer|year_released|repeat|captions|final|colour|running_time|language|genre|live)/); # parsed fields
			next if ($field =~ /(program_id|series_id|genre_id|venue_id|y7_url|highlight)/); # ignored fields
			next if (defined $d->{ignored_field}->{$field});
			$d->{ignored_field}->{$field} = 1;
			Shepherd::Common::log("ignoring unknown field '$field'");
		}
	}
}

######################################################################################################

sub write_data
{
	my %writer_args = ( encoding => 'ISO-8859-1' );
	if ($opt->{outputfile}) {
		my $fh = new IO::File(">$opt->{outputfile}")  or die "can't open $opt->{outputfile}: $!";
		$writer_args{OUTPUT} = $fh;
	}

	my $writer = new XMLTV::Writer(%writer_args);

	$writer->start
	  ( { 'source-info-name'   => "$progname $version",
	      'generator-info-name' => "$progname $version"} );

	for my $channel (sort keys %{$channels}) {
		$writer->write_channel( {'display-name' => [[ $channel, $opt->{lang} ]], 'id' => $channels->{$channel}} )
		  if (defined $d->{seen_progs}->{$channel});
	}
	for my $channel (sort keys %{$opt_channels}) {
		$writer->write_channel( {'display-name' => [[ $channel, $opt->{lang} ]], 'id' => $opt_channels->{$channel}} )
		  if (defined $d->{seen_progs}->{$channel});
	}

	my $abc2_eariest_start = "300000000000";

	for my $channel (sort keys %{($d->{seen_progs})}) {
		for my $event_id (sort {$a cmp $b} keys %{($tv_guide->{$channel}->{data})}) {
			my $show = $tv_guide->{$channel}->{data}->{$event_id};
			Shepherd::Common::cleanup($show);
			$writer->write_programme($show);

			$abc2_eariest_start = $show->{'start'}
					if ($channel eq "ABC2" && $abc2_eariest_start > $show->{'start'});
		}
	}

	# check if abc2 has a gap on the first day when the station is closed
	if ($abc2_eariest_start != "300000000000" && (!defined $opt->{offset}) && defined $channels->{ABC2} &&
			$abc2_eariest_start > POSIX::strftime("%Y%m%d%H%M", localtime($starttime))) {

		# create 7am today
		my @timeattr = localtime($script_start_time); # 0=sec,1=min,2=hour,3=day,4=month,5=year,6=wday,7=yday,8=isdst
		$timeattr[0] = 0; # zero seconds
		$timeattr[1] = 0; # min
		$timeattr[2] = 7; # hours 7am
		my $time7am = mktime(@timeattr);
		$time7am -= $time_offset;
		my $xmltime7am = POSIX::strftime("%Y%m%d%H%M", localtime($time7am));

		if (($starttime < $time7am) && ($abc2_eariest_start == $xmltime7am))
		{
			my $show;
			$show->{'channel'} =    $channels->{ABC2};
			$show->{'title'} =      [[ "Station Close Guess", $opt->{lang} ]];
			$show->{'start'} =      POSIX::strftime("%Y%m%d%H%M", localtime($starttime));
			$show->{'stop'} =       $abc2_eariest_start;

			Shepherd::Common::cleanup($show);
			$writer->write_programme($show);
		}
	}

	$writer->end();
}

######################################################################################################

